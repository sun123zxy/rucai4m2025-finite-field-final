import Mathlib

open Set

-- H01: If G is an infinite cyclic group, then all elements of G have infinite order
lemma infinite_cyclic_group_infinite_order (G : Type*) [Group G] [IsCyclic G] [Infinite G] :
  âˆ€ g : G, g â‰  1 â†’ orderOf g = 0 :=
sorry

-- H02: E/F is a field extension, g âˆˆ E, if g is integral over F,
-- then F[g] is finite dimensional over F
lemma adjoin_finite_of_integral (F E : Type*) [Field F] [Field E] [Algebra F E] (g : E)
    (h : IsIntegral F g) : FiniteDimensional F (IntermediateField.adjoin F {g}) := by
    refine IntermediateField.adjoin.finiteDimensional h

-- Helper lemma: If F is a field of characteristic 2 and FË£ is cyclic, then F is finite
lemma finite_of_char_two_cyclic (F : Type*) [Field F] [CharP F 2] [IsCyclic FË£] :
  Finite F := by

  -- Since char F = 2, we have an algebra structure F over ZMod 2
  haveI : Algebra (ZMod 2) F := ZMod.algebra _ _

  -- Say FË£ is generated by g
  obtain âŸ¨g, hgâŸ© := @IsCyclic.exists_generator FË£ _ _

  -- Then g is integral over ğ”½â‚‚
  have g_integral : IsIntegral (ZMod 2) (g.val : F) := by
    -- we are to show that g + 1 = g ^ n for some n
    rw [â† isAlgebraic_iff_isIntegral]

    by_cases gp1_ne : 1 + g.val = 0
    Â· apply_fun (fun x => x - 1) at gp1_ne
      ring_nf at gp1_ne
      use Polynomial.X - 1
      rw [CharTwo.neg_eq] at gp1_ne
      rw [gp1_ne]
      simp only [ne_eq, map_sub, Polynomial.aeval_X, map_one, sub_self, and_true]
      exact Polynomial.X_sub_C_ne_zero 1
    Â· obtain âŸ¨gâ‚, hgâ‚âŸ© := FiniteDimensional.isUnit F gp1_ne
      obtain âŸ¨n, hnâŸ© := hg gâ‚
      simp only at hn
      rw [â† hn] at hgâ‚

      by_cases n_neg : n < 0
      Â· let n' := (-n).toNat
        apply_fun (fun x => x * g.val ^ (-n)) at hgâ‚
        rw [add_mul] at hgâ‚
        norm_cast at hgâ‚
        conv at hgâ‚ => rhs; rhs; congr; lhs; rw [show g = g ^ (1:â„¤) by simp]
        repeat rw [â†zpow_add] at hgâ‚
        conv at hgâ‚ => lhs; simp only [add_neg_cancel, zpow_zero, Units.val_one]
        rw [show -n = n' by
          unfold n'; simp only [Int.ofNat_toNat, left_eq_sup, Int.neg_nonneg]; linarith] at hgâ‚
        norm_cast at hgâ‚
        simp at hgâ‚
        use (Polynomial.X ^ (1 + n') + Polynomial.X ^ n' - 1)
        constructor
        Â· sorry
        Â· simp [hgâ‚]
          ring

      push_neg at n_neg
      let n' := n.toNat
      rw [show n = n' by unfold n'; simp only [Int.ofNat_toNat, left_eq_sup]; linarith] at hgâ‚
      simp only [zpow_natCast, Units.val_pow_eq_pow_val] at hgâ‚
      use (Polynomial.X ^ n' - Polynomial.X - 1)
      simp only [ne_eq, map_sub, map_pow, Polynomial.aeval_X, hgâ‚, add_sub_cancel_right, map_one,
        sub_self, and_true]
      sorry

  -- Then F = ğ”½â‚‚[g]
  have field_eq : (âŠ¤ : IntermediateField (ZMod 2) F) =
    IntermediateField.adjoin (ZMod 2) {g.val} := sorry

  -- Conclude that F is finite, by H02
  haveI : FiniteDimensional (ZMod 2) (IntermediateField.adjoin (ZMod 2) {g.val}) :=
    adjoin_finite_of_integral (ZMod 2) F g.val g_integral

  -- Since F = ğ”½â‚‚[g] and ğ”½â‚‚[g] is finite dimensional over ğ”½â‚‚, F is finite dimensional
  haveI : FiniteDimensional (ZMod 2) F := sorry

  -- Since ğ”½â‚‚ is finite and F is finite dimensional over ğ”½â‚‚, F is finite
  exact sorry

-- Main theorem: If F is a field with cyclic multiplicative group, then F is finite
theorem finite_field_of_cyclic_units (F : Type*) [Field F] [IsCyclic FË£] :
  Finite F := by

  -- Proof by contradiction
  by_contra h_infinite

  -- Assume F is infinite
  haveI : Infinite F := not_finite_iff_infinite.mp h_infinite

  -- Then FË£ is infinite
  haveI : Infinite FË£ := by
    -- åè¯æ³•ï¼šå‡è®¾å•ä½ç¾¤æœ‰é™
    haveI kâ‚: Infinite F := not_finite_iff_infinite.mp h_infinite
    by_contra h_finite_unit
    -- è·å–å•ä½ç¾¤æœ‰é™çš„å®ä¾‹
    have : Finite FË£ := Finite.of_not_infinite h_finite_unit
    -- å°†æ•´ä¸ªåŸŸåˆ†è§£ä¸ºé›¶å…ƒç´ å’Œå•ä½ç¾¤çš„å¹¶é›†
    have : (univ : Set F) = {0} âˆª (Set.range (Units.val : FË£ â†’ F)) := by
      ext x
      simp only [mem_univ, singleton_union, mem_insert_iff, mem_range, true_iff]
      by_cases x=0
      Â· left
        (expose_names; exact h)
      Â· right
        have pâ‚:x â‰  0:=by
          (expose_names; exact h)
        refine CanLift.prf x ?_
        simp
        exact pâ‚
    have set_finite : Set.Finite (univ : Set F) := by
      rw [this]  -- åº”ç”¨é›†åˆåˆ†è§£
      apply Set.Finite.union
      Â· exact finite_singleton 0  -- å•ç‚¹é›†{0}æœ‰é™
      Â· exact finite_range Units.val
    -- ä¸åŸŸçš„æ— é™æ€§å‡è®¾çŸ›ç›¾
    have : Set.Infinite (univ : Set F) :=by
      exact infinite_univ_iff.mpr kâ‚
    exact this set_finite

   -- Then FË£ â‰… â„¤ by H01 (all non-identity elements have infinite order)
  have h_infinite_order := infinite_cyclic_group_infinite_order FË£

  -- Then char F = 2 (use h_infinite_order)
  haveI : CharP F 2 := sorry

  -- Then F is finite by H04 and the fact that char 2 + cyclic units implies finite field
  have h_finite : Finite F := finite_of_char_two_cyclic F

  -- Contradiction with our assumption that F is infinite
  exact h_infinite h_finite
