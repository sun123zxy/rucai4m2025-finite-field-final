import Mathlib

open Set

-- H01: If G is an infinite cyclic group, then all elements of G have infinite order
lemma infinite_cyclic_group_infinite_order (G : Type*) [Group G] [IsCyclic G] [Infinite G] :
  ∀ g : G, g ≠ 1 → orderOf g = 0 := by
  rcases @IsCyclic.exists_generator G _ _ with ⟨g, hg⟩
  intro u hu
  have : orderOf g = 0 := by
    apply Infinite.orderOf_eq_zero_of_forall_mem_zpowers hg
  have gu : ∃ k : ℤ, g ^ k = u := by
    have gu' : u ∈ Subgroup.zpowers g := hg u
    simp [Subgroup.zpowers] at gu'
    exact gu'
  rcases gu with ⟨k, hk⟩
  rw [← hk]
  refine orderOf_eq_zero_iff'.mpr ?_
  intro n hn
  rw [orderOf_eq_zero_iff'] at this
  contrapose! this
  by_cases zk : k = 0
  · simp [zk] at hk
    exfalso
    exact hu (Eq.symm hk)
  by_cases gk : k > 0
  · use (Int.toNat k) * n
    simp [gk, hn]
    rw [pow_mul, ← this]
    congr 1
    rw [← zpow_natCast]
    congr 1
    omega
  have lk : k < 0 := by omega
  use Int.natAbs k * n
  simp [lk, hn]
  constructor
  · exact zk
  rw [pow_mul]
  have this' : (g ^ (-k)) ^ n = 1 := by
    rw [← inv_one, ← this]
    group
  rw [← this']
  congr 1
  rw [← zpow_natCast]
  congr 1
  omega

-- H02: E/F is a field extension, g ∈ E, if g is integral over F,
-- then F[g] is finite dimensional over F
lemma adjoin_finite_of_integral (F E : Type*) [Field F] [Field E] [Algebra F E] (g : E)
    (h : IsIntegral F g) : FiniteDimensional F (IntermediateField.adjoin F {g}) := by
    refine IntermediateField.adjoin.finiteDimensional h

-- Helper lemma: If F is a field of characteristic 2 and Fˣ is cyclic, then F is finite
lemma finite_of_char_two_cyclic (F : Type*) [Field F] [CharP F 2] [IsCyclic Fˣ] :
  Finite F := by

  -- Since char F = 2, we have an algebra structure F over ZMod 2
  haveI : Algebra (ZMod 2) F := ZMod.algebra _ _

  -- Say Fˣ is generated by g
  obtain ⟨g, hg⟩ := @IsCyclic.exists_generator Fˣ _ _

  -- Then g is integral over 𝔽₂
  have g_integral : IsIntegral (ZMod 2) (g.val : F) := by
    -- we are to show that g + 1 = g ^ n for some n
    rw [← isAlgebraic_iff_isIntegral]

    by_cases gp1_ne : 1 + g.val = 0
    · apply_fun (fun x => x - 1) at gp1_ne
      ring_nf at gp1_ne
      use Polynomial.X - 1
      rw [CharTwo.neg_eq] at gp1_ne
      rw [gp1_ne]
      simp only [ne_eq, map_sub, Polynomial.aeval_X, map_one, sub_self, and_true]
      exact Polynomial.X_sub_C_ne_zero 1
    · obtain ⟨g₁, hg₁⟩ := FiniteDimensional.isUnit F gp1_ne
      obtain ⟨n, hn⟩ := hg g₁
      simp only at hn
      rw [← hn] at hg₁

      have n_ne_zero : n ≠ 0 := by
        intro h
        rw [h] at hg₁
        simp at hg₁

      by_cases n_neg : n < 0
      · let n' := (-n).toNat
        apply_fun (fun x => x * g.val ^ (-n)) at hg₁
        rw [add_mul] at hg₁
        norm_cast at hg₁
        conv at hg₁ => rhs; rhs; congr; lhs; rw [show g = g ^ (1:ℤ) by simp]
        repeat rw [←zpow_add] at hg₁
        conv at hg₁ => lhs; simp only [add_neg_cancel, zpow_zero, Units.val_one]
        rw [show -n = n' by
          unfold n'; simp only [Int.ofNat_toNat, left_eq_sup, Int.neg_nonneg]; linarith] at hg₁
        norm_cast at hg₁
        simp at hg₁
        use (Polynomial.X ^ (1 + n') + Polynomial.X ^ n' - 1)
        constructor
        · intro tmp
          apply_fun fun f => f.aeval (0 : F) at tmp
          simp at tmp
          haveI : n' ≠ 0 := by
            unfold n'
            simp only [ne_eq, Int.toNat_eq_zero, Left.neg_nonpos_iff, not_le]
            linarith
          rw [zero_pow this] at tmp
          simp at tmp
        · simp [hg₁]
          ring

      push_neg at n_neg
      let n' := n.toNat
      rw [show n = n' by unfold n'; simp only [Int.ofNat_toNat, left_eq_sup]; linarith] at hg₁
      simp only [zpow_natCast, Units.val_pow_eq_pow_val] at hg₁
      use (Polynomial.X ^ n' - Polynomial.X - 1)
      simp only [ne_eq, map_sub, map_pow, Polynomial.aeval_X, hg₁, add_sub_cancel_right, map_one,
        sub_self, and_true]
      intro tmp

      apply_fun fun f => f.aeval (0 : F) at tmp
      simp at tmp
      haveI : n' ≠ 0 := by
        unfold n'
        by_contra! h
        apply n_ne_zero
        rw [← Int.toNat_of_nonneg n_neg, h]
        simp
      rw [zero_pow this] at tmp
      simp at tmp

  -- Then F = 𝔽₂[g]
  have field_eq : (⊤ : IntermediateField (ZMod 2) F) =
    IntermediateField.adjoin (ZMod 2) {g.val} := by
    ext x
    constructor
    · intro _
      by_cases hx_zero : x = 0
      · rw [hx_zero]
        exact IntermediateField.zero_mem (IntermediateField.adjoin (ZMod 2) {g.val})
      · -- x ≠ 0, so x ∈ Fˣ
        have x_unit : IsUnit x := FiniteDimensional.isUnit F hx_zero
        obtain ⟨u, hu⟩ := x_unit
        -- u ∈ Fˣ, so u = g^k for some k
        obtain ⟨k, hk⟩ := hg u
        rw [← hu, ← hk]
        -- g^k ∈ 𝔽₂[g]
        simp only [Units.val_zpow_eq_zpow_val]
        apply IntermediateField.pow_mem
        apply IntermediateField.subset_adjoin
        simp only [mem_singleton_iff]
    · intro hx
      simp only [IntermediateField.mem_top]
  -- Conclude that F is finite, by H02
  haveI : FiniteDimensional (ZMod 2) (IntermediateField.adjoin (ZMod 2) {g.val}) :=
    adjoin_finite_of_integral (ZMod 2) F g.val g_integral

  -- Since F = 𝔽₂[g] and 𝔽₂[g] is finite dimensional over 𝔽₂, F is finite dimensional
  haveI : FiniteDimensional (ZMod 2) F := by
    have iso : (⊤ : IntermediateField (ZMod 2) F) ≃ₐ[ZMod 2] F :=
      IntermediateField.topEquiv
    symm at iso
    rw [field_eq] at iso
    exact FiniteDimensional.of_injective iso.toLinearMap iso.injective
  -- Since 𝔽₂ is finite and F is finite dimensional over 𝔽₂, F is finite
  exact Module.finite_of_finite (ZMod 2)


-- Main theorem: If F is a field with cyclic multiplicative group, then F is finite
theorem finite_field_of_cyclic_units (F : Type*) [Field F] [IsCyclic Fˣ] :
  Finite F := by

  -- Proof by contradiction
  by_contra h_infinite

  -- Assume F is infinite
  haveI : Infinite F := not_finite_iff_infinite.mp h_infinite

  -- Then Fˣ is infinite
  haveI : Infinite Fˣ := by
    -- 反证法：假设单位群有限
    haveI k₁: Infinite F := not_finite_iff_infinite.mp h_infinite
    by_contra h_finite_unit
    -- 获取单位群有限的实例
    have : Finite Fˣ := Finite.of_not_infinite h_finite_unit
    -- 将整个域分解为零元素和单位群的并集
    have : (univ : Set F) = {0} ∪ (Set.range (Units.val : Fˣ → F)) := by
      ext x
      simp only [mem_univ, singleton_union, mem_insert_iff, mem_range, true_iff]
      by_cases x=0
      · left
        (expose_names; exact h)
      · right
        have p₁:x ≠ 0:=by
          (expose_names; exact h)
        refine CanLift.prf x ?_
        simp
        exact p₁
    have set_finite : Set.Finite (univ : Set F) := by
      rw [this]  -- 应用集合分解
      apply Set.Finite.union
      · exact finite_singleton 0  -- 单点集{0}有限
      · exact finite_range Units.val
    -- 与域的无限性假设矛盾
    have : Set.Infinite (univ : Set F) :=by
      exact infinite_univ_iff.mpr k₁
    exact this set_finite

   -- Then Fˣ ≅ ℤ by H01 (all non-identity elements have infinite order)
  have h_infinite_order := infinite_cyclic_group_infinite_order Fˣ

  -- Then char F = 2 (use h_infinite_order)
  haveI : CharP F 2 := sorry

  -- Then F is finite by H04 and the fact that char 2 + cyclic units implies finite field
  have h_finite : Finite F := finite_of_char_two_cyclic F

  -- Contradiction with our assumption that F is infinite
  exact h_infinite h_finite
