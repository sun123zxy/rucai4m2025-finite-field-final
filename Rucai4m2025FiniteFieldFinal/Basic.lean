import Mathlib

open Set

lemma finite_of_finite_units (F : Type*) [Field F] [Finite FÀ£] : Finite F := by
  -- Show that F = FÀ£ ‚à™ {0}
  have h_eq : (Set.univ : Set F) = Set.range Units.val ‚à™ {0} := by
    ext x
    simp only [mem_univ, union_singleton, mem_insert_iff, mem_range, true_iff]
    by_cases hx_zero : x = 0
    ¬∑ left
      assumption
    ¬∑ right
      exact FiniteDimensional.isUnit F hx_zero
  -- Therefore F is finite
  rw [‚Üê Set.finite_univ_iff, h_eq]
  apply Set.Finite.union
  ¬∑ exact Set.finite_range Units.val
  ¬∑ exact Set.finite_singleton 0

-- H01: If G is an infinite cyclic group, then all elements of G have infinite order
lemma orderOf_eq_zero_of_cyclic_of_infinite (G : Type*) [Group G] [IsCyclic G] [Infinite G] :
    ‚àÄ g : G, g ‚â† 1 ‚Üí orderOf g = 0 := by
  -- First acquire a generator g satisfying the conclusion
  rcases @IsCyclic.exists_generator G _ _ with ‚ü®g, hg‚ü©
  intro u hu
  have : orderOf g = 0 := by
    apply Infinite.orderOf_eq_zero_of_forall_mem_zpowers hg
  have gu : ‚àÉ k : ‚Ñ§, g ^ k = u := by
    have gu' : u ‚àà Subgroup.zpowers g := hg u
    simp [Subgroup.zpowers] at gu'
    exact gu'
  rcases gu with ‚ü®k, hk‚ü©
  -- replace u by power of g
  rw [‚Üê hk]
  refine orderOf_eq_zero_iff'.mpr ?_
  intro n hn
  rw [orderOf_eq_zero_iff'] at this
  contrapose! this
  by_cases zk : k = 0
  ¬∑ simp [zk] at hk
    exfalso
    exact hu (Eq.symm hk)
  by_cases gk : k > 0
  ¬∑ use (Int.toNat k) * n
    simp [gk, hn]
    rw [pow_mul, ‚Üê this]
    congr 1
    rw [‚Üê zpow_natCast]
    congr 1
    omega
  have lk : k < 0 := by omega
  use Int.natAbs k * n
  simp [hn]
  constructor
  ¬∑ exact zk
  rw [pow_mul]
  have this' : (g ^ (-k)) ^ n = 1 := by
    rw [‚Üê inv_one, ‚Üê this]
    group
  rw [‚Üê this']
  congr 1
  rw [‚Üê zpow_natCast]
  congr 1
  omega

lemma simple_extension_of_cyclic_generator
    (F : Type*) {E : Type*} [Field F] [Field E] [Algebra F E]
    (g : EÀ£) (hg : ‚àÄ (x : EÀ£), x ‚àà Subgroup.zpowers g) :
    ‚ä§ = IntermediateField.adjoin F {g.val} := by
  ext x
  constructor
  ¬∑ intro _
    by_cases hx_zero : x = 0
    ¬∑ rw [hx_zero]
      exact IntermediateField.zero_mem (IntermediateField.adjoin F {g.val})
    ¬∑ -- x ‚â† 0, so x ‚àà FÀ£
      have x_unit : IsUnit x := FiniteDimensional.isUnit E hx_zero
      obtain ‚ü®u, hu‚ü© := x_unit
      -- u ‚àà FÀ£, so u = g^k for some k
      obtain ‚ü®k, hk‚ü© := hg u
      rw [‚Üê hu, ‚Üê hk]
      -- g^k ‚àà ùîΩ‚ÇÇ[g]
      simp only [Units.val_zpow_eq_zpow_val]
      apply IntermediateField.pow_mem
      apply IntermediateField.subset_adjoin
      simp only [mem_singleton_iff]
  ¬∑ intro hx
    simp only [IntermediateField.mem_top]

-- Partial result: If F is a field of characteristic 2 and FÀ£ is cyclic, then F is finite
lemma finite_of_char_two_of_cyclic (F : Type*) [Field F] [CharP F 2] [IsCyclic FÀ£] :
    Finite F := by
  -- Since char F = 2, we have an algebra structure F over ZMod 2
  haveI : Algebra (ZMod 2) F := ZMod.algebra _ _

  -- Say FÀ£ is generated by g
  obtain ‚ü®g, hg‚ü© := IsCyclic.exists_generator (Œ± := FÀ£)

  -- Then g is integral over ùîΩ‚ÇÇ
  have g_integral : IsIntegral (ZMod 2) (g.val : F) := by
    -- we are to show that g + 1 = g ^ n for some n
    rw [‚Üê isAlgebraic_iff_isIntegral]

    by_cases gp1_ne : 1 + g.val = 0
    ¬∑ apply_fun (fun x => x - 1) at gp1_ne
      ring_nf at gp1_ne
      use Polynomial.X - 1
      rw [CharTwo.neg_eq] at gp1_ne
      rw [gp1_ne]
      simp only [ne_eq, map_sub, Polynomial.aeval_X, map_one, sub_self, and_true]
      exact Polynomial.X_sub_C_ne_zero 1
    ¬∑ obtain ‚ü®g‚ÇÅ, hg‚ÇÅ‚ü© := FiniteDimensional.isUnit F gp1_ne
      obtain ‚ü®n, hn‚ü© := hg g‚ÇÅ
      simp only at hn
      rw [‚Üê hn] at hg‚ÇÅ

      have n_ne_zero : n ‚â† 0 := by
        intro h
        rw [h] at hg‚ÇÅ
        simp at hg‚ÇÅ

      by_cases n_neg : n < 0
      ¬∑ let n' := (-n).toNat
        apply_fun (fun x => x * g.val ^ (-n)) at hg‚ÇÅ
        rw [add_mul] at hg‚ÇÅ
        norm_cast at hg‚ÇÅ
        conv at hg‚ÇÅ => rhs; rhs; congr; lhs; rw [show g = g ^ (1:‚Ñ§) by simp]
        repeat rw [‚Üêzpow_add] at hg‚ÇÅ
        conv at hg‚ÇÅ => lhs; simp only [add_neg_cancel, zpow_zero, Units.val_one]
        rw [show -n = n' by
          unfold n'
          simp only [Int.ofNat_toNat, left_eq_sup, Int.neg_nonneg]
          linarith] at hg‚ÇÅ
        norm_cast at hg‚ÇÅ
        simp at hg‚ÇÅ
        use (Polynomial.X ^ (1 + n') + Polynomial.X ^ n' - 1)
        constructor
        ¬∑ intro tmp
          apply_fun fun f => f.aeval (0 : F) at tmp
          simp at tmp
          haveI : n' ‚â† 0 := by
            unfold n'
            simp only [ne_eq, Int.toNat_eq_zero, Left.neg_nonpos_iff, not_le]
            linarith
          rw [zero_pow this] at tmp
          simp at tmp
        ¬∑ simp [hg‚ÇÅ]
          ring

      push_neg at n_neg
      let n' := n.toNat
      rw [show n = n' by
        unfold n'
        simp only [Int.ofNat_toNat, left_eq_sup]
        linarith] at hg‚ÇÅ
      simp only [zpow_natCast, Units.val_pow_eq_pow_val] at hg‚ÇÅ
      use (Polynomial.X ^ n' - Polynomial.X - 1)
      simp only [ne_eq, map_sub, map_pow, Polynomial.aeval_X, hg‚ÇÅ,
        add_sub_cancel_right, map_one, sub_self, and_true]
      intro tmp

      apply_fun fun f => f.aeval (0 : F) at tmp
      simp at tmp
      haveI : n' ‚â† 0 := by
        unfold n'
        by_contra! h
        apply n_ne_zero
        rw [‚Üê Int.toNat_of_nonneg n_neg, h]
        simp
      rw [zero_pow this] at tmp
      simp at tmp

  -- Show that F = ùîΩ‚ÇÇ[g]
  have field_eq : (‚ä§ : IntermediateField (ZMod 2) F) =
      IntermediateField.adjoin (ZMod 2) {g.val} :=
    simple_extension_of_cyclic_generator (ZMod 2) g hg

  -- Conclude that F is finite
  haveI : FiniteDimensional (ZMod 2) (IntermediateField.adjoin (ZMod 2) {g.val}) :=
    IntermediateField.adjoin.finiteDimensional g_integral

  -- Since F = ùîΩ‚ÇÇ[g] and ùîΩ‚ÇÇ[g] is finite dimensional over ùîΩ‚ÇÇ, F is finite dimensional
  haveI : FiniteDimensional (ZMod 2) F := by
    have iso : (‚ä§ : IntermediateField (ZMod 2) F) ‚âÉ‚Çê[ZMod 2] F :=
      IntermediateField.topEquiv
    symm at iso
    rw [field_eq] at iso
    exact FiniteDimensional.of_injective iso.toLinearMap iso.injective
  -- Since ùîΩ‚ÇÇ is finite and F is finite dimensional over ùîΩ‚ÇÇ, F is finite
  exact Module.finite_of_finite (ZMod 2)

-- Main theorem: If F is a field with cyclic multiplicative group, then F is finite
theorem finite_field_of_cyclic_units (F : Type*) [Field F] [IsCyclic FÀ£] :
    Finite F := by
  -- Proof by contradiction
  by_contra h_infinite

  -- Assume F is infinite
  haveI : Infinite F := not_finite_iff_infinite.mp h_infinite

  -- Then FÀ£ is infinite
  haveI : Infinite FÀ£ := by
    contrapose! h_infinite
    simp only [not_infinite_iff_finite] at h_infinite
    exact finite_of_finite_units F

  -- Then FÀ£ ‚âÖ ‚Ñ§ gives out that all non-identity elements have an infinite order
  have h_infinite_order := orderOf_eq_zero_of_cyclic_of_infinite FÀ£

  -- Then char F = 2 (use h_infinite_order)
  haveI : CharP F 2 := by
    -- First show that -1 has finite order in F*
    specialize h_infinite_order (-1 : FÀ£)
    contrapose! h_infinite_order
    constructor
    ¬∑ haveI : ringChar F ‚â† 2 := by
        contrapose! h_infinite_order
        haveI := ringChar.charP F
        rw [h_infinite_order] at this
        exact this
      -- haveI := CharP.char_is_prime F
      contrapose! this
      rw [‚Üê neg_one_eq_one_iff]
      apply_fun (fun x => x.val) at this
      exact this
    ¬∑ simp
      rw [‚Üê orderOf_units]
      push_cast
      rw [orderOf_neg_one]
      haveI : ringChar F ‚â† 2 := by
        intro h_char
        haveI := ringChar.charP F
        rw [h_char] at this
        contradiction
      simp [this]

  -- Then F is finite and the fact that char 2 and cyclic units implies finite field
  have h_finite : Finite F := finite_of_char_two_of_cyclic F

  -- Contradiction with our assumption that F is infinite
  exact h_infinite h_finite
