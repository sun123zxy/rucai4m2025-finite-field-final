import Mathlib

/-!
# Finite Fields with Cyclic Multiplicative Groups

This file proves that every field with a cyclic multiplicative group is finite.

## Main Results

- `Field.finite_of_cyclic_units`: The main theorem showing that if F is a field
  with cyclic unit group FÀ£, then F is finite.

## Proof Strategy

1. `finite_of_finite_units`: Basic lemma that if FÀ£ is finite, then F is finite
2. `orderOf_eq_zero_of_cyclic_of_infinite`: Non-identity element in an infinite cyclic group is of
                                            order 0
3. `simple_extension_of_cyclic_generator`: Adjoining a generator of cyclic unit group
                                           gives the whole field
4. `Field.finite_of_char_two_of_cyclic_units`: Proves the main theorem in the characteristic 2 case
-/

open Set

/-- If the group of units of a field F is finite, then F itself is finite.
    This follows from the fact that F = FÀ£ ‚à™ {0}. -/
lemma finite_of_finite_units (F : Type*) [Field F] [Finite FÀ£] : Finite F := by
  -- Show that F = FÀ£ ‚à™ {0}
  have h_eq : (Set.univ : Set F) = Set.range Units.val ‚à™ {0} := by
    ext x
    simp only [mem_univ, union_singleton, mem_insert_iff, mem_range, true_iff]
    by_cases hx_zero : x = 0
    ¬∑ left
      assumption
    ¬∑ right
      exact FiniteDimensional.isUnit F hx_zero
  -- Therefore F is finite
  rw [‚Üê Set.finite_univ_iff, h_eq]
  apply Set.Finite.union
  ¬∑ exact Set.finite_range Units.val
  ¬∑ exact Set.finite_singleton 0

/-- In an infinite cyclic group G, every non-identity element has infinite order.
    This is because if G is infinite and cyclic, then G ‚âÖ ‚Ñ§, and in ‚Ñ§ every non-zero element
    generates an infinite subgroup. -/
lemma orderOf_eq_zero_of_cyclic_of_infinite (G : Type*) [Group G] [IsCyclic G] [Infinite G] :
    ‚àÄ g : G, g ‚â† 1 ‚Üí orderOf g = 0 := by
  -- First acquire a generator of G
  rcases @IsCyclic.exists_generator G _ _ with ‚ü®g, hg‚ü©
  intro u hu
  -- Show that the generator g has infinite order
  have : orderOf g = 0 := by
    apply Infinite.orderOf_eq_zero_of_forall_mem_zpowers hg
  -- Any element u can be written as a power of the generator g
  have gu : ‚àÉ k : ‚Ñ§, g ^ k = u := by
    have gu' : u ‚àà Subgroup.zpowers g := hg u
    simp only [Subgroup.zpowers, Subgroup.mem_mk, mem_range] at gu'
    exact gu'
  rcases gu with ‚ü®k, hk‚ü©
  -- Replace u by g^k and show that g^k also has infinite order
  rw [‚Üê hk]
  refine orderOf_eq_zero_iff'.mpr ?_
  intro n hn
  rw [orderOf_eq_zero_iff'] at this
  contrapose! this
  -- Case analysis on the sign of k
  by_cases zk : k = 0
  ¬∑ -- If k = 0, then u = 1, contradicting u ‚â† 1
    simp only [zk, zpow_zero] at hk
    exfalso
    exact hu (Eq.symm hk)
  by_cases gk : k > 0
  ¬∑ -- If k > 0, use the fact that (g^k)^n = g^(kn) = 1 implies g^(kn) = 1
    use (Int.toNat k) * n
    simp only [Int.lt_toNat, CharP.cast_eq_zero, gk, mul_pos_iff_of_pos_left, hn, true_and]
    rw [pow_mul, ‚Üê this]
    congr 1
    rw [‚Üê zpow_natCast]
    congr 1
    omega
  -- If k < 0, use similar reasoning with absolute value
  have lk : k < 0 := by omega
  use Int.natAbs k * n
  simp only [hn, mul_pos_iff_of_pos_right, Int.natAbs_pos, ne_eq]
  constructor
  ¬∑ exact zk
  rw [pow_mul]
  -- Use the fact that g^(-|k|) = (g^|k|)^(-1)
  have this' : (g ^ (-k)) ^ n = 1 := by
    rw [‚Üê inv_one, ‚Üê this]
    group
  rw [‚Üê this']
  congr 1
  rw [‚Üê zpow_natCast]
  congr 1
  omega

/-- If E is a field extension of F and the unit group EÀ£ is generated by a single element g,
    then E = F[g]. This shows that E is a simple extension of F generated by g. -/
lemma simple_extension_of_cyclic_generator
    (F : Type*) {E : Type*} [Field F] [Field E] [Algebra F E]
    (g : EÀ£) (hg : ‚àÄ (x : EÀ£), x ‚àà Subgroup.zpowers g) :
    ‚ä§ = IntermediateField.adjoin F {g.val} := by
  ext x
  constructor
  ¬∑ intro _
    -- Every element x ‚àà E is either 0 or a unit
    by_cases hx_zero : x = 0
    ¬∑ -- If x = 0, then x ‚àà F[g]
      rw [hx_zero]
      exact IntermediateField.zero_mem (IntermediateField.adjoin F {g.val})
    ¬∑ -- If x ‚â† 0, then x ‚àà EÀ£
      have x_unit : IsUnit x := FiniteDimensional.isUnit E hx_zero
      obtain ‚ü®u, hu‚ü© := x_unit
      -- Since g generates all of EÀ£, we have u = g^k for some integer k
      obtain ‚ü®k, hk‚ü© := hg u
      rw [‚Üê hu, ‚Üê hk]
      -- Therefore x = g^k ‚àà F[g]
      simp only [Units.val_zpow_eq_zpow_val]
      apply IntermediateField.pow_mem
      apply IntermediateField.subset_adjoin
      simp only [mem_singleton_iff]
  ¬∑ -- The reverse inclusion is trivial: F[g] ‚äÜ E = ‚ä§
    intro hx
    simp only [IntermediateField.mem_top]

/-- If F is a field of characteristic 2 with a cyclic unit group, then F is finite.
    This is proved by showing that the generator of the unit group is algebraic, so that
    the extension F/ùîΩ‚ÇÇ ‚âÉ ùîΩ‚ÇÇ[g] is finite dimensional. -/
lemma Field.finite_of_char_two_of_cyclic_units (F : Type*) [Field F] [CharP F 2] [IsCyclic FÀ£] :
    Finite F := by
  -- Since char F = 2, we have a natural algebra structure F over ùîΩ‚ÇÇ
  haveI : Algebra (ZMod 2) F := ZMod.algebra _ _

  -- Since FÀ£ is cyclic, let g be a generator of FÀ£
  obtain ‚ü®g, hg‚ü© := IsCyclic.exists_generator (Œ± := FÀ£)

  -- Show that g is algebraic over ùîΩ‚ÇÇ. We shall find a polynomial relation it satisfies.
  have g_integral : IsIntegral (ZMod 2) (g.val : F) := by
    rw [‚Üê isAlgebraic_iff_isIntegral]

    by_cases gp1_ne : 1 + g.val = 0
    ¬∑ -- Case 1: 1 + g = 0, so g = -1 = 1 (in characteristic 2)
      apply_fun (fun x => x - 1) at gp1_ne
      ring_nf at gp1_ne
      use Polynomial.X - 1
      rw [CharTwo.neg_eq] at gp1_ne
      rw [gp1_ne]
      simp only [ne_eq, map_sub, Polynomial.aeval_X, map_one, sub_self, and_true]
      exact Polynomial.X_sub_C_ne_zero 1
    ¬∑ -- Case 2: 1 + g ‚â† 0, so 1 + g is a unit, hence a power of g
      obtain ‚ü®g‚ÇÅ, hg‚ÇÅ‚ü© := FiniteDimensional.isUnit F gp1_ne
      obtain ‚ü®n, hn‚ü© := hg g‚ÇÅ
      simp only at hn
      rw [‚Üê hn] at hg‚ÇÅ
      -- n cannot be zero (otherwise 1 + g = 1, so g = 0, contradiction)
      have n_ne_zero : n ‚â† 0 := by
        intro h
        rw [h] at hg‚ÇÅ
        simp at hg‚ÇÅ

      by_cases n_neg : n < 0
      ¬∑ -- Case 2.1: n < 0
        let n' := (-n).toNat
        apply_fun (fun x => x * g.val ^ (-n)) at hg‚ÇÅ
        rw [add_mul] at hg‚ÇÅ
        norm_cast at hg‚ÇÅ
        conv at hg‚ÇÅ => rhs; rhs; congr; lhs; rw [show g = g ^ (1:‚Ñ§) by simp]
        repeat rw [‚Üêzpow_add] at hg‚ÇÅ
        conv at hg‚ÇÅ => lhs; simp only [add_neg_cancel, zpow_zero, Units.val_one]
        rw [show -n = n' by
          unfold n'
          simp only [Int.ofNat_toNat, left_eq_sup, Int.neg_nonneg]
          linarith] at hg‚ÇÅ
        norm_cast at hg‚ÇÅ
        simp only [Units.val_pow_eq_pow_val, one_mul] at hg‚ÇÅ
        -- g satisfies the polynomial X^(1+n') + X^n' - 1 = 0
        use (Polynomial.X ^ (1 + n') + Polynomial.X ^ n' - 1)
        constructor
        ¬∑ intro tmp
          apply_fun fun f => f.aeval (0 : F) at tmp
          simp only [map_sub, map_add, map_pow, Polynomial.aeval_X, ne_eq, Nat.add_eq_zero,
            one_ne_zero, false_and, not_false_eq_true, zero_pow, zero_add, map_one, map_zero] at tmp
          haveI : n' ‚â† 0 := by
            unfold n'
            simp only [ne_eq, Int.toNat_eq_zero, Left.neg_nonpos_iff, not_le]
            linarith
          rw [zero_pow this] at tmp
          simp only [zero_sub, neg_eq_zero, one_ne_zero] at tmp
        ¬∑ simp only [map_sub, map_add, map_pow, Polynomial.aeval_X, map_one, hg‚ÇÅ]
          ring
      ¬∑ -- Case 2.2: n ‚â• 0
        push_neg at n_neg
        let n' := n.toNat
        rw [show n = n' by
          unfold n'
          simp only [Int.ofNat_toNat, left_eq_sup]
          linarith] at hg‚ÇÅ
        simp only [zpow_natCast, Units.val_pow_eq_pow_val] at hg‚ÇÅ
        -- g satisfies the polynomial X^n' - X - 1 = 0
        use (Polynomial.X ^ n' - Polynomial.X - 1)
        simp only [ne_eq, map_sub, map_pow, Polynomial.aeval_X, hg‚ÇÅ,
          add_sub_cancel_right, map_one, sub_self, and_true]
        intro tmp

        apply_fun fun f => f.aeval (0 : F) at tmp
        simp only [map_sub, map_pow, Polynomial.aeval_X, sub_zero, map_one, map_zero] at tmp
        haveI : n' ‚â† 0 := by
          unfold n'
          by_contra! h
          apply n_ne_zero
          rw [‚Üê Int.toNat_of_nonneg n_neg, h]
          simp only [CharP.cast_eq_zero]
        rw [zero_pow this] at tmp
        simp only [zero_sub, neg_eq_zero, one_ne_zero] at tmp

  -- Since g is integral over ùîΩ‚ÇÇ, the extension ùîΩ‚ÇÇ[g] is finite dimensional
  haveI : FiniteDimensional (ZMod 2) (IntermediateField.adjoin (ZMod 2) {g.val}) :=
    IntermediateField.adjoin.finiteDimensional g_integral

  -- But F = ùîΩ‚ÇÇ[g]
  have field_eq : (‚ä§ : IntermediateField (ZMod 2) F) =
      IntermediateField.adjoin (ZMod 2) {g.val} :=
    simple_extension_of_cyclic_generator (ZMod 2) g hg

  -- Thus F is finite dimensional over ùîΩ‚ÇÇ
  haveI : FiniteDimensional (ZMod 2) F := by
    have iso : (‚ä§ : IntermediateField (ZMod 2) F) ‚âÉ‚Çê[ZMod 2] F :=
      IntermediateField.topEquiv
    symm at iso
    rw [field_eq] at iso
    exact FiniteDimensional.of_injective iso.toLinearMap iso.injective

  -- Since ùîΩ‚ÇÇ is finite and F is finite dimensional over ùîΩ‚ÇÇ, F is finite
  exact Module.finite_of_finite (ZMod 2)

/-- Every field with a cyclic unit group is finite.
    The proof is by contradiction: if F is infinite with cyclic FÀ£, then all non-identity
    elements of FÀ£ have infinite order, but -1 has order 2 unless char F = 2. So char F = 2,
    and then F is finite by the previous lemma. -/
theorem Field.finite_of_cyclic_units (F : Type*) [Field F] [IsCyclic FÀ£] :
    Finite F := by
  -- Proof by contradiction - assume F is infinite
  by_contra h_infinite

  -- If F is infinite, then so is FÀ£ (since F = FÀ£ ‚à™ {0})
  haveI : Infinite F := not_finite_iff_infinite.mp h_infinite

  haveI : Infinite FÀ£ := by
    contrapose! h_infinite
    simp only [not_infinite_iff_finite] at h_infinite
    exact finite_of_finite_units F

  -- In an infinite cyclic group, all non-identity elements have infinite order
  have h_infinite_order := orderOf_eq_zero_of_cyclic_of_infinite FÀ£

  -- But -1 has order 2 unless char F = 2, so char F = 2
  haveI : CharP F 2 := by
    -- Show that -1 must have finite order unless char F = 2
    specialize h_infinite_order (-1 : FÀ£)
    contrapose! h_infinite_order
    constructor
    ¬∑ -- Show -1 ‚â† 1 (unless char F = 2)
      haveI : ringChar F ‚â† 2 := by
        contrapose! h_infinite_order
        haveI := ringChar.charP F
        rw [h_infinite_order] at this
        exact this
      contrapose! this
      rw [‚Üê neg_one_eq_one_iff]
      apply_fun (fun x => x.val) at this
      exact this
    ¬∑ -- Compute the orderOf (-1)
      rw [‚Üê orderOf_units]
      push_cast
      rw [orderOf_neg_one]
      haveI : ringChar F ‚â† 2 := by
        intro h_char
        haveI := ringChar.charP F
        rw [h_char] at this
        contradiction
      simp [this]

  -- Now char F = 2 and FÀ£ cyclic, so F is finite by our lemma
  have h_finite : Finite F := finite_of_char_two_of_cyclic_units F

  -- This contradicts our assumption that F is infinite
  exact h_infinite h_finite
